1.single responsibility principle 单一职责原则
单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。单一职责原则定义
如下： 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责
个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原
因。
单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）
承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些
职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责
进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果
多个职责总是同时发生改变则可将它们封装在同一类中。
单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设
计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设
计能力和相关实践经验。
![demo](/SRP1.png)
![demo](/SRP2.png)
2.Open-Closed Principle 开闭原则
一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下
进行扩展。
为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在Java、C#等
编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现
层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系
统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何
改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩
展系统的功能，达到开闭原则的要求。
![demo](/OCP1.png)
![demo](/OCP2.png)
3.里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类
  （父类）的地方必须能透明地使用其子类的对象。
  里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对
  象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用
  子类对象来替换父类对象。
  (1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代
  换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在
  子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。
  (2) 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现
  父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地
  扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类
  来实现。里氏代换原则是开闭原则的具体实现手段之一。
  (3) Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个
  与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。
 ![demo](/LSP1.png)
 ![demo](/LSP2.png)
4.依赖倒转原则(Dependency Inversion Principle, DIP)：抽象不应该依赖于细节，细节应
  当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。
  依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层
  类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据
  类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只
  实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增
  加的新方法。
  在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体
  类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改
  配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭
  原则的要求。
  在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入
  (DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发
  生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注
  入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，
  设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务
  方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型
  的对象，由子类对象来覆盖父类对象。
5.接口隔离原则(Interface Segregation Principle, ISP)：使用多个专门的接口，而不使用单一
  的总接口，即客户端不应该依赖那些它不需要的接口。
6.合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复
  用的目的。合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些
       已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能
       的目的。简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。
一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继
承。"Is-A"是严格的分类学意义上的定义，意思是一个类是另一个类的"一种"；而"Has-A"则不
同，它表示某一个角色具有某一项责任。
7.迪米特法则(Law of Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作
  用。
  如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他
  模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之
  间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关
  系。
  迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等，在迪
  米特法则中，对于一个对象，其朋友包括以下几类：
  (1) 当前对象本身(this)；
  (2) 以参数形式传入到当前对象方法中的对象；
  (3) 当前对象的成员对象；
  (4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；
  (5) 当前对象所创建的对象。
  任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。在应
  用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做
  可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。